[{"content":"Hey there, it\u0026rsquo;s Rezy Dev! Today, we’re going to talk about one of the most important parts of Rust programming—memory management. If you\u0026rsquo;ve been keeping up, you know Rust focuses on safety and performance, and memory management is key to that.\nUnderstanding memory management is essential for writing efficient and safe Rust code. We’ll explore how Rust handles memory using concepts like The Stack, The Heap, Ownership, Borrowing, and more. Ready? Let’s get started!\nThe Stack, the Heap, and Pointers Rust uses two main memory areas: the stack and the heap.\nThe Stack: Think of the stack as a fast and organized place for storing data that has a fixed size and known lifetime. Variables that you define in functions are stored here. It’s like a stack of plates: you add and remove plates in a Last In, First Out (LIFO) order. For example:\nfn stack_example() { let a = 10; // Stored on the stack let b = 20; // Stored on the stack let c = a + b; // Computed and stored on the stack } The Heap: The heap is for data with a dynamic size or unknown size at compile time. It’s like a large storage room where you can put objects and take them out as needed. This comes into play with data that might change in size, like vectors or strings. Here’s an example:\nfn heap_example() { let mut v = Vec::new(); // Vector on the heap v.push(1); v.push(2); let mut s = String::from(\u0026#34;Mom, I\u0026#39;m a hacker.\u0026#34;); // String on the heap println!(\u0026#34;{}\u0026#34;, s); } Ownership and Borrowing Rust’s unique approach to memory management involves ownership and borrowing. This system prevents data races and ensures memory safety.\nOwnership: Every value in Rust has a single owner, and when the owner goes out of scope, the value is automatically dropped. Here’s a basic example:\nfn ownership_example() { let x = String::from(\u0026#34;Mom, I\u0026#39;m a hacker.\u0026#34;); // x owns the string let y = x; // Ownership of the string is transferred to y // println!(\u0026#34;{}\u0026#34;, x); // Error: x no longer owns the string println!(\u0026#34;{}\u0026#34;, y); // Works fine: y owns the string now } Borrowing: You can also borrow a value without taking ownership of it. This is useful for functions that need to read but not modify the data.\nfn borrowing_example(s: \u0026amp;String) { println!(\u0026#34;{}\u0026#34;, s); // Borrowing s, read-only } fn main() { let s = String::from(\u0026#34;Mom, I\u0026#39;m a hacker.\u0026#34;); borrowing_example(\u0026amp;s); // Borrow s println!(\u0026#34;{}\u0026#34;, s); // s is still valid } Mutable References: If you need to modify the data, you can borrow it mutably. Note that you can only have one mutable reference to a value at a time.\nfn mutable_borrow_example(s: \u0026amp;mut String) { s.push_str(\u0026#34;, world!\u0026#34;); } fn main() { let mut s = String::from(\u0026#34;Hello\u0026#34;); mutable_borrow_example(\u0026amp;mut s); // Mutable borrow println!(\u0026#34;{}\u0026#34;, s); // s has been modified } Giving References to Functions: When passing references to functions, ensure that you follow Rust’s borrowing rules to avoid conflicts.\nfn process_string(s: \u0026amp;String) { // Process the string } fn main() { let s = String::from(\u0026#34;Mom, I\u0026#39;m a hacker.\u0026#34;); process_string(\u0026amp;s); // Passing a reference } Copy Types Some types in Rust implement the Copy trait, allowing them to be copied rather than moved. This is generally for simple, fixed-size types like integers.\nfn copy_example() { let a = 5; // i32 is a Copy type let b = a; // Copying a to b println!(\u0026#34;a: {}, b: {}\u0026#34;, a, b); // Both a and b are valid } Lifetimes Lifetimes in Rust are used to ensure that references are valid as long as they are needed. They prevent dangling references and help manage memory safety.\nfn longest\u0026lt;\u0026#39;a\u0026gt;(s1: \u0026amp;\u0026#39;a str, s2: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str { if s1.len() \u0026gt; s2.len() { s1 } else { s2 } } fn main() { let s1 = String::from(\u0026#34;long string\u0026#34;); let s2 = String::from(\u0026#34;short\u0026#34;); let result = longest(\u0026amp;s1, \u0026amp;s2); println!(\u0026#34;The longest string is {}\u0026#34;, result); } Further Reading Since I\u0026rsquo;ve only provided a general overview of how these concepts work, I recommend checking out the following resources for a clearer and more detailed understanding, which will help you become a better programmer. :)\nThe Rust Programming Language - Ownership\nRust Reference - Lifetimes\nRust by Example - Borrowing\nRust Official Documentation - The Stack and the Heap\nRust Official Documentation - Copy Types\nThat’s a wrap for today’s exploration of memory management in Rust! I hope you found this post both informative and fun. As always, feel free to reach out with any questions or comments. Until next time, happy coding!\n","permalink":"http://localhost:1313/posts/rust/memory-management-in-rust/","summary":"Hey there, it\u0026rsquo;s Rezy Dev! Today, we’re going to talk about one of the most important parts of Rust programming—memory management. If you\u0026rsquo;ve been keeping up, you know Rust focuses on safety and performance, and memory management is key to that.\nUnderstanding memory management is essential for writing efficient and safe Rust code. We’ll explore how Rust handles memory using concepts like The Stack, The Heap, Ownership, Borrowing, and more. Ready?","title":"Memory Management in Rust"},{"content":"Welcome back to my Rust series! Today, we\u0026rsquo;re exploring some key concepts: data types and variables. Whether you\u0026rsquo;re working with data during a pentest or creating a custom tool, knowing how Rust manages these basics is crucial.\nTypes In Rust, every value has a specific type, and understanding these types is crucial, especially when handling different data structures. Rust is a statically typed language, which means that all variable types are known at compile time. This feature helps in catching bugs early, something we all appreciate during a lengthy pentest engagement.\nHere’s a quick overview of some basic types:\nIntegers: For when you need to count something (u8, i32, u64, etc.).\nFloating-Point Numbers: Perfect for dealing with calculations that require precision, like timing the response of a server (f32, f64).\nBooleans: True or False, often used in condition checks (bool).\nCharacters: Represents a single character (char).\nTuples: Group multiple values of different types into one compound type.\nArrays: Fixed-size collection of elements, all of the same type. Ideal for holding things like a list of common passwords or IP addresses.\nExample:\nlet ip_addresses: [u8; 4] = [192, 168, 1, 1]; let port_number: u16 = 8080; let is_open: bool = true; Here, ip_addresses is an array of four u8 elements representing an IPv4 address. The port_number is stored as a u16 integer, and is_open is a boolean that might represent the state of a port after a scan.\nType Inference Rust is smart. It often knows the type of a variable without you explicitly telling it. This is called type inference. While Rust’s compiler is very good at figuring out the type, there are times when you need to be explicit, especially when dealing with more complex types or when you want to avoid ambiguity.\nFor example:\nlet response_time = 120.5; // concluded as f64 let host = \u0026#34;10.0.0.1\u0026#34;; // concluded as \u0026amp;str Rust concludes that response_time is an f64 and host is a string slice (\u0026amp;str). This saves time and keeps the code clean.\nMutability In Rust, variables are immutable by default. This is great for security since it prevents accidental modification of data. But, sometimes you need to change the value of a variable, like when updating the status of a service after an exploit. In such cases, you can declare the variable as mutable using the mut keyword.\nExample:\nlet mut service_status = \u0026#34;running\u0026#34;; println!(\u0026#34;Service status: {}\u0026#34;, service_status); service_status = \u0026#34;exploited\u0026#34;; println!(\u0026#34;Service status: {}\u0026#34;, service_status); In this case, service_status starts as \u0026quot;running\u0026quot; but is later updated to \u0026quot;exploited\u0026quot;. By marking the variable as mut, Rust allows this change.\nConstants and static Variables When you know a value won\u0026rsquo;t change throughout the lifecycle of your program, you use a constant. Constants are declared using the const keyword and must always be typed.\nconst MAX_ATTEMPTS: u8 = 5; Here, MAX_ATTEMPTS might represent the number of times you’ll attempt a brute-force attack before moving on.\nRust also has static variables, which are similar to constants but are static items with a fixed address in memory. They can hold references, and unlike constants, they can be mutable (though mutable static variables are not recommended due to potential data races).\nstatic TIMEOUT: u64 = 3000; In this example, TIMEOUT could represent a global timeout value used throughout your application.\nStrings Working with text is something we often do in pentesting, whether it\u0026rsquo;s manipulating payloads, parsing responses, or logging results. Rust provides two main string types: String and \u0026amp;str.\nString: A heap-allocated, growable string. Use this when you need to own and manipulate the string.\n\u0026amp;str: A string slice, which is a reference to a part of a String. It’s useful for passing strings around without needing to own them.\nExample:\nlet payload = String::from(\u0026#34;GET / HTTP/1.1\\r\\nHost: raunak.xyz\\r\\n\\r\\n\u0026#34;); let host = \u0026amp;payload[16..26]; // \u0026#34;raunak.xyz\u0026#34; Here, payload is a String that holds an HTTP request, and host is a \u0026amp;str that slices a part of the payload.\nPrinting with Display and Debug When it comes to outputting data, Rust provides two main formatting traits: Display and Debug.\nDisplay: Used for user-facing output, typically meant to be more readable.\nDebug: Used for developer-facing output, often more detailed and suitable for debugging.\nLet’s say we’re printing out the result of an exploitation attempt:\nlet exploit_result = (\u0026#34;target.com\u0026#34;, 80, true); println!(\u0026#34;Exploit attempt: {:?}\u0026#34;, exploit_result); // Debug println!(\u0026#34;Target: {}, Port: {}, Success: {}\u0026#34;, exploit_result.0, exploit_result.1, exploit_result.2); // Display Using {:?}, we can print a tuple with Debug formatting, and using {}, we can print individual components with Display formatting.\nMore about Printing Rust also supports more complex formatting through macros like format!, print!, and println!.\nlet exploit_result = (\u0026#34;target.com\u0026#34;, 80, true); let report = format!(\u0026#34;Target: {}\\nPort: {}\\nSuccess: {}\u0026#34;, exploit_result.0, exploit_result.1, exploit_result.2); println!(\u0026#34;{}\u0026#34;, report); Here, format! creates a formatted string that we can then print or log.\nConclusion Mastering data types and variables in Rust is key to writing efficient, secure, and strong code. By using Rust’s type system and mutability features, you can manage different data situations accurately and safely.\nFurther Reading The Rust Programming Language - Data Types\nRust By Example - Variables\nRust Reference - Variables and Types\nRust Language - Constants and Static Variables\nRust Documentation - Formatting\n","permalink":"http://localhost:1313/posts/rust/data-types-and-variables-in-rust/","summary":"Welcome back to my Rust series! Today, we\u0026rsquo;re exploring some key concepts: data types and variables. Whether you\u0026rsquo;re working with data during a pentest or creating a custom tool, knowing how Rust manages these basics is crucial.\nTypes In Rust, every value has a specific type, and understanding these types is crucial, especially when handling different data structures. Rust is a statically typed language, which means that all variable types are known at compile time.","title":"Data Types and Variables in Rust"},{"content":"Hey there! I\u0026rsquo;m really pumped to take you on a journey into the world of Rust today. We\u0026rsquo;re going to write our very first Rust program, and I\u0026rsquo;ll explain some key concepts along the way to help you feel like a pro. Let\u0026rsquo;s dive in!\nCargo: The Build System and Package Manager Before we start coding, let\u0026rsquo;s talk about Cargo. Think of Cargo as your best friend in Rust. It\u0026rsquo;s the official build system and package manager for Rust, and it\u0026rsquo;s a game-changer. With Cargo, you can easily manage your projects, handle dependencies, run tests, and even build documentation—all from the command line.\nCargo makes compiling and managing a Rust project much simpler. Instead of manually compiling your code with rustc, Cargo does it for you. It\u0026rsquo;s like having a tool that automates boring tasks, letting you focus on the fun parts.\nSo, why use Cargo instead of rustc directly? While rustc is good for compiling individual files, Cargo is designed for managing whole projects. It helps you keep track of dependencies, ensures your project is built consistently, and makes it easy to share your code with others. In short, Cargo makes life easier, just like how tools like metasploit or nmap make finding vulnerabilities simpler.\nCreating a New Rust Project with Cargo Now, let’s create our first Rust project using Cargo. Open up your terminal and type:\ncargo new hello_rust This command creates a new directory called hello_rust with some files and folders inside. But what exactly did Cargo set up for us?\nWhen you create a project with Cargo, it generates a directory structure that looks something like this:\nCargo.toml: This is the configuration file for your project. It’s written in TOML (Tom’s Obvious, Minimal Language). Here, you can specify your project’s name, version, dependencies, and other metadata. It\u0026rsquo;s like the settings.py in a Django project or package.json in a Node.js project.\nsrc/: This directory contains all your Rust source files. By default, Cargo creates a main.rs file here, which is the entry point of your Rust application.\nCargo also keeps track of a cargo.lock file (once you start adding dependencies). This file ensures that everyone who builds your project uses the exact same versions of your dependencies, maintaining consistency—a crucial aspect in software development.\nWriting Your First Rust Program Alright, enough with the theory—let\u0026rsquo;s write some code! Open the main.rs file inside the src/ directory. You’ll see something like this:\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); } This simple program prints \u0026ldquo;Hello, world!\u0026rdquo; to the console. It\u0026rsquo;s a classic starting point in almost every programming language, and Rust is no exception.\nPrinting in Rust The println! macro is Rust’s way of printing text to the console. Notice the exclamation mark !—this indicates that println! is a macro, not a regular function. Macros in Rust are powerful tools that allow you to write code that writes other code, which can be incredibly useful in many situations. For now, just remember that println! is your go-to for outputting text.\nTo run your program, simply type:\ncargo run Cargo will compile your code and execute the resulting binary. You should see \u0026ldquo;Hello, world!\u0026rdquo; printed on your terminal.\nComments: Documenting Your Code Now that we\u0026rsquo;ve got our program running, let’s talk about comments. As a pentester, I can\u0026rsquo;t stress enough how important it is to document your work. Whether you\u0026rsquo;re writing a pentest report or coding, clear documentation is key.\nRust supports two main types of comments:\nSingle-line comments: These start with // and extend to the end of the line.\n// This is a single-line comment Multi-line comments: These are enclosed in /* */ and can span multiple lines.\n/* This is a multi-line comment. Useful for longer explanations or disabling blocks of code. */ Rust also supports documentation comments, which are a special kind of comment used to generate external documentation. Documentation comments (/// for single lines and /** */ for multiple lines) are used to create API documentation for your code. This is similar to how you might write comments in other languages to explain what a piece of code does, but in Rust, these comments can be automatically compiled into rich, formatted documentation.\n/// This function prints a greeting to the console. fn greet() { println!(\u0026#34;Hello, world!\u0026#34;); } Commenting your code is crucial because it helps others (and your future self) understand what’s happening in your code. It\u0026rsquo;s like leaving breadcrumbs during a pentest to trace your steps or providing detailed explanations in a report.\nConclusion And there you have it—your first Rust program! We\u0026rsquo;ve covered a lot of ground today, from understanding Cargo and its directory structure to writing and running a simple \u0026ldquo;Hello, world!\u0026rdquo; program. We also touched on the importance of comments and documentation in code.\nAs we continue our Rust journey, we\u0026rsquo;ll dive deeper into more complex topics, but for now, enjoy the satisfaction of seeing that \u0026ldquo;Hello, world!\u0026rdquo; printed on your screen. Rust is a powerful language with a lot to offer, and I can’t wait to explore more of it with you.\nHappy coding, and keep documenting!\n","permalink":"http://localhost:1313/posts/rust/writing-our-first-rust-program/","summary":"Hey there! I\u0026rsquo;m really pumped to take you on a journey into the world of Rust today. We\u0026rsquo;re going to write our very first Rust program, and I\u0026rsquo;ll explain some key concepts along the way to help you feel like a pro. Let\u0026rsquo;s dive in!\nCargo: The Build System and Package Manager Before we start coding, let\u0026rsquo;s talk about Cargo. Think of Cargo as your best friend in Rust. It\u0026rsquo;s the official build system and package manager for Rust, and it\u0026rsquo;s a game-changer.","title":"Writing Our First Rust Program"},{"content":"Introduction Rust is a modern programming language that has become popular because it combines speed, control, and safety. It offers the performance and control of languages like C and C++, while also ensuring memory safety, which is a big advantage seen in newer languages like Python. Rust uses new ideas that might be different from what you know in other languages, so it needs careful thought and understanding.\nOne challenge with Rust is that it needs a more structured way of learning. You can\u0026rsquo;t just \u0026ldquo;figure things out as you go.\u0026rdquo; Instead, you need to understand it deeply and practice deliberately.\nRust may be new, but with the right approach, you can master it and write efficient, safe, and reliable code.\nInstallation of Rust in Linux In this series, we will use Linux. The following command should install Rust on our system:\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh Also, make sure to install the CodeLLDB and Rust Analyzer extensions in VS Code so that we can write our Rust code here.\nNow that we have a general overview of Rust and have installed and configured it in VS Code, let\u0026rsquo;s talk about using Rust for cybersecurity\u0026hellip;\nRust for Cybersecurity Rust is becoming a strong tool in cybersecurity, providing many benefits for tasks like penetration testing, automation, bug bounty hunting, and malware development. Its mix of speed, safety, and modern features makes it perfect for these areas. Here’s why Rust is becoming popular in cybersecurity:\n1. Penetration Testing Performance and Control: Rust gives you the low-level access needed for tasks like network scanning, packet crafting, and exploiting vulnerabilities. It offers the speed and control of languages like C or C++, which is important for real-time applications in penetration testing.\nMemory Safety: One of Rust’s best features is its ability to prevent common memory-related issues (e.g., buffer overflows) that can cause security problems. This ensures that the tools you create are not only effective but also secure.\n2. Automation Concurrency: Rust’s ownership model and concurrency features make it great for writing safe, concurrent applications. This is especially useful for automating repetitive tasks in cybersecurity, like brute-forcing passwords or running large-scale scans.\nCross-Platform Development: Rust’s cross-compilation capabilities let you write tools that work well on different operating systems, from Linux to Windows, making your automated tools more versatile.\n3. Bug Bounty Hunting Tooling: Rust is great for making custom tools and scripts for specific bug bounty tasks. Its speed ensures your tools can manage large datasets and complex tasks quickly and efficiently.\nReliability: Rust’s strong type system and compile-time checks help prevent bugs in your tools, allowing you to focus on finding bugs in other systems without worrying about your own tools\u0026rsquo; reliability.\n4. Malware Development Stealth and Efficiency: Rust can create small, efficient programs, which is useful for making lightweight malware that is hard to detect. Its speed also allows for quick execution of harmful actions.\nObfuscation: Rust’s complicated syntax and structure make it harder to reverse engineer, adding extra security for malware developers.\n5. General Benefits Growing Ecosystem: Rust’s ecosystem is growing fast, with many libraries and frameworks useful for cybersecurity tasks. From cryptography libraries to networking crates, Rust has you covered.\nCommunity and Support: The Rust community is very helpful and is expanding quickly in the cybersecurity field. This means as you start using Rust, you’ll have plenty of knowledge and support available.\nConclusion In conclusion, Rust is not just another modern programming language; it\u0026rsquo;s a vital tool for cybersecurity professionals. Whether you’re building sophisticated penetration testing tools, automating complex security tasks, hunting for vulnerabilities, or even developing advanced malware, Rust offers the perfect balance of performance, safety, and flexibility. As the landscape of cybersecurity continues to shift and grow, Rust\u0026rsquo;s influence in the field is poised to expand, making it an essential language for those looking to stay ahead in the game. This marks the beginning of an exciting journey into Rust for cybersecurity on my blog. Stay tuned as we dive deeper into how this powerful language can enhance your skills and projects in the cybersecurity domain.\n","permalink":"http://localhost:1313/posts/rust/introduction-and-installation-of-rust-language/","summary":"Introduction Rust is a modern programming language that has become popular because it combines speed, control, and safety. It offers the performance and control of languages like C and C++, while also ensuring memory safety, which is a big advantage seen in newer languages like Python. Rust uses new ideas that might be different from what you know in other languages, so it needs careful thought and understanding.\nOne challenge with Rust is that it needs a more structured way of learning.","title":"Introduction and Installation of Rust Language"},{"content":"██████╗ ███████╗███████╗██╗ ██╗██████╗ ███████╗██╗ ██╗ ██╔══██╗██╔════╝╚══███╔╝╚██╗ ██╔╝██╔══██╗██╔════╝██║ ██║ ██████╔╝█████╗ ███╔╝ ╚████╔╝ ██║ ██║█████╗ ██║ ██║ ██╔══██╗██╔══╝ ███╔╝ ╚██╔╝ ██║ ██║██╔══╝ ╚██╗ ██╔╝ ██║ ██║███████╗███████╗ ██║ ██████╔╝███████╗ ╚████╔╝ ╚═╝ ╚═╝╚══════╝╚══════╝ ╚═╝ ╚═════╝ ╚══════╝ ╚═══╝ Security Nerd | Rust Dev | CTF Player 🛡️ Personals: My legal name is Raunak Neupane 🙋 I\u0026rsquo;m pursuing Bachlors degree (CS Major) 🎓 I\u0026rsquo;m from Nepal 🇳🇵 Current Hustles: 🕵️‍♂️ Digging through web exploits \u0026amp; 🐛 squashing bugs! 🦀 Jamming with Rust—it’s not just for metal. On My Radar: 🚀 Experimenting with new Rust frameworks and hacking tools. 🛠️ Always chasing the next CTF challenge! Peek into my projects: GitHub Portfolio\nLatest writeups: /posts\nAsk me about: Penetration Testing 💻 Rust Programming 🦀 Python Programming 🐍 Reach me at: me [@] rezydev.xyz ","permalink":"http://localhost:1313/whoami/","summary":"██████╗ ███████╗███████╗██╗ ██╗██████╗ ███████╗██╗ ██╗ ██╔══██╗██╔════╝╚══███╔╝╚██╗ ██╔╝██╔══██╗██╔════╝██║ ██║ ██████╔╝█████╗ ███╔╝ ╚████╔╝ ██║ ██║█████╗ ██║ ██║ ██╔══██╗██╔══╝ ███╔╝ ╚██╔╝ ██║ ██║██╔══╝ ╚██╗ ██╔╝ ██║ ██║███████╗███████╗ ██║ ██████╔╝███████╗ ╚████╔╝ ╚═╝ ╚═╝╚══════╝╚══════╝ ╚═╝ ╚═════╝ ╚══════╝ ╚═══╝ Security Nerd | Rust Dev | CTF Player 🛡️ Personals: My legal name is Raunak Neupane 🙋 I\u0026rsquo;m pursuing Bachlors degree (CS Major) 🎓 I\u0026rsquo;m from Nepal 🇳🇵 Current Hustles: 🕵️‍♂️ Digging through web exploits \u0026amp; 🐛 squashing bugs!","title":""},{"content":"Hello guys, this year PTN is hosting 24 hour CTF competition in celebration of 11th Anniversary. The CTF is styled in jeopardy mode. So I, rezydev is playing this CTF with NCA1@Nepal. Let\u0026rsquo;s get into CTF writeup now.\nNo one goes empty handed! The CTF was supposed to be started at 3:00 PM NPT but we were supposed to register our team at 12:00 noon. So, I registered my team and was just looking around the website to read \u0026ldquo;CTF Competition Rules\u0026rdquo;. I have a habit of highlighting the text i read on screen. All I did was highlighted the whole text and found few letters which were hidden. Since the color code f7f7f7 is a very light shade of gray, few texts were hidden and I assembled all the hidden texts which gave me a flag: PTNCTF24{sanity_check}. And to be honest, I don\u0026rsquo;t know if this is just there or what as the CTF wasn\u0026rsquo;t started yet, but i can confirm it\u0026rsquo;s part of OSINT. Nvm, it was for \u0026ldquo;No one goes empty handed!\u0026rdquo;. Haha, so let\u0026rsquo;s go.\nI tried alot with OSINT \u0026amp; Web but no success, but for fun I tried reverse engineering.\nReverse Engineering E-reverse They gave us a file PasswordChecker.class which is a Java Class. I ran ghidra and put the file in it. This is the ghidra output:\n#include \u0026#34;out.h\u0026#34; // Flags: // ACC_PUBLIC // // public PasswordChecker() void \u0026lt;init\u0026gt;_void(PasswordChecker this) { this.\u0026lt;init\u0026gt;(); return; } // Flags: // ACC_PUBLIC // ACC_STATIC // // public static void main(java.lang.String[]) void main_java_lang_String___void(String[] param1) { PrintStream pPVar1; String pSVar2; boolean bVar3; Scanner objectRef; objectRef = new Scanner(System_in); pPVar1 = System_out; pPVar1.print(\u0026#34;Enter the password: \u0026#34;); pSVar2 = objectRef.nextLine(); bVar3 = PasswordChecker_checkPassword(pSVar2); if (bVar3) { pPVar1 = System_out; pPVar1.println(\u0026#34;Access granted!\u0026#34;); } else { pPVar1 = System_out; pPVar1.println(\u0026#34;Access denied!\u0026#34;); } objectRef.close(); return; } // Flags: // ACC_PRIVATE // ACC_STATIC // // private static boolean checkPassword(java.lang.String) boolean checkPassword_java_lang_String_boolean(String param1) { Base64_Decoder objectRef; byte[] pbVar1; String pSVar2; boolean bVar3; StringBuilder objectRef_00; StringBuilder pSVar4; dword pdVar5; int iVar6; int iVar7; int iVar8; objectRef_00 = new StringBuilder(); pdVar5 = PasswordChecker_ENCODED_PARTS; iVar6 = pdVar5.length; iVar7 = 0; while( true ) { if (iVar6 \u0026lt;= iVar7) break; pSVar2 = pdVar5[iVar7]; objectRef = Base64_getDecoder(); pbVar1 = objectRef.decode(pSVar2); iVar8 = PasswordChecker_SALTS.length; while (iVar8 = iVar8 + -1, -1 \u0026lt; iVar8) { pbVar1 = PasswordChecker_xorWithSalt(pbVar1,PasswordChecker_SALTS[iVar8]); } pSVar4 = objectRef_00; pSVar2 = new String(pbVar1); objectRef_00.append(pSVar2); iVar7 = iVar7 + 1; objectRef_00 = pSVar4; } pSVar2 = objectRef_00.toString(); bVar3 = pSVar2.equals(param1); return bVar3; } // Flags: // ACC_PRIVATE // ACC_STATIC // // private static byte[] xorWithSalt(byte[], byte) byte[] xorWithSalt_byte___byte_byte__(byte[] param1,byte param2) { byte[] pbVar1; int iVar2; pbVar1 = new byte[param1.length]; iVar2 = 0; while( true ) { if (param1.length \u0026lt;= iVar2) break; pbVar1[iVar2] = param1[iVar2] ^ param2; iVar2 = iVar2 + 1; } return pbVar1; } // Flags: // ACC_STATIC // // static (class initializer) void \u0026lt;clinit\u0026gt;_void(void) { String[] ppSVar1; byte[] pbVar2; ppSVar1 = new String[9]; ppSVar1[0] = \u0026#34;bGhyf2g=\u0026#34;; ppSVar1[1] = \u0026#34;eg4IR3Y=\u0026#34;; ppSVar1[2] = \u0026#34;CEoIYw0=\u0026#34;; ppSVar1[3] = \u0026#34;CWN6SXI=\u0026#34;; ppSVar1[4] = \u0026#34;YwgJYw0=\u0026#34;; ppSVar1[5] = \u0026#34;SAljWQg=\u0026#34;; ppSVar1[6] = \u0026#34;CUVjSAw=\u0026#34;; ppSVar1[7] = \u0026#34;Y05ZSlk=\u0026#34;; ppSVar1[8] = \u0026#34;TglZQQ==\u0026#34;; PasswordChecker_ENCODED_PARTS = ppSVar1; pbVar2 = new byte[4]; pbVar2[0] = 0x5a; pbVar2[1] = 0x3c; pbVar2[2] = 0x77; pbVar2[3] = 0x2d; PasswordChecker_SALTS = pbVar2; return; } I cleaned up the above code for java(ofcourse using AI):\nimport java.util.Base64; import java.util.Scanner; public class PasswordChecker { private static final String[] ENCODED_PARTS = { \u0026#34;bGhyf2g=\u0026#34;, \u0026#34;eg4IR3Y=\u0026#34;, \u0026#34;CEoIYw0=\u0026#34;, \u0026#34;CWN6SXI=\u0026#34;, \u0026#34;YwgJYw0=\u0026#34;, \u0026#34;SAljWQg=\u0026#34;, \u0026#34;CUVjSAw=\u0026#34;, \u0026#34;Y05ZSlk=\u0026#34;, \u0026#34;TglZQQ==\u0026#34; }; private static final byte[] SALTS = {0x5a, 0x3c, 0x77, 0x2d}; public PasswordChecker() { // Constructor } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;Enter the password: \u0026#34;); String inputPassword = scanner.nextLine(); if (checkPassword(inputPassword)) { System.out.println(\u0026#34;Access granted!\u0026#34;); } else { System.out.println(\u0026#34;Access denied!\u0026#34;); } scanner.close(); } private static boolean checkPassword(String inputPassword) { StringBuilder decodedString = new StringBuilder(); for (String encodedPart : ENCODED_PARTS) { byte[] decodedBytes = Base64.getDecoder().decode(encodedPart); for (int i = SALTS.length - 1; i \u0026gt;= 0; i--) { decodedBytes = xorWithSalt(decodedBytes, SALTS[i]); } decodedString.append(new String(decodedBytes)); } return decodedString.toString().equals(inputPassword); } private static byte[] xorWithSalt(byte[] data, byte salt) { byte[] result = new byte[data.length]; for (int i = 0; i \u0026lt; data.length; i++) { result[i] = (byte) (data[i] ^ salt); } return result; } } The above code prompts the user to enter a password. It then decodes a series of Base64-encoded strings, applies a series of XOR operations using predefined salt values to the decoded byte arrays, and concatenates the results. The final decoded string is compared with the user input. If they match, access is granted; otherwise, access is denied. We can use the folliwing java code:\nimport java.util.Base64; public class ReverseEngineerPassword { // Encoded parts of the password private static final String[] ENCODED_PARTS = { \u0026#34;bGhyf2g=\u0026#34;, \u0026#34;eg4IR3Y=\u0026#34;, \u0026#34;CEoIYw0=\u0026#34;, \u0026#34;CWN6SXI=\u0026#34;, \u0026#34;YwgJYw0=\u0026#34;, \u0026#34;SAljWQg=\u0026#34;, \u0026#34;CUVjSAw=\u0026#34;, \u0026#34;Y05ZSlk=\u0026#34;, \u0026#34;TglZQQ==\u0026#34; }; // Salts for XOR operation private static final byte[] SALTS = { 0x5a, 0x3c, 0x77, 0x2d }; public static void main(String[] args) { // Step 1 \u0026amp; 2: Decode Base64 strings StringBuilder password = new StringBuilder(); for (String part : ENCODED_PARTS) { byte[] decodedBytes = Base64.getDecoder().decode(part); // Step 3: Apply XOR with salts for (byte salt : SALTS) { decodedBytes = xorWithSalt(decodedBytes, salt); } // Step 4: Reconstruct the password password.append(new String(decodedBytes)); } // Print the reconstructed password System.out.println(\u0026#34;Reconstructed Password: \u0026#34; + password.toString()); } private static byte[] xorWithSalt(byte[] data, byte salt) { byte[] result = new byte[data.length]; for (int i = 0; i \u0026lt; data.length; i++) { result[i] = (byte) (data[i] ^ salt); } return result; } } This outputs us the flag as PTNCTF24{J4v4_15_FuN_45_1t5_e45y_t0_rever5e}. You may ask why? The above program reconstructs the password by:\nDecoding: It decodes each Base64-encoded string in ENCODED_PARTS. XOR Operations: Each decoded byte array is XORed sequentially with the bytes in the SALTS array to reverse the obfuscation. Concatenation: The results of the XOR operations are concatenated into a single string. Output: The concatenated string is printed, revealing the original password or flag. The flag PTNCTF24{J4v4_15_FuN_45_1t5_e45y_t0_rever5e} is the original password obfuscated by the encoding and XOR process.\nMisc decrypt It gave us a hash: $y$j9T$dYMhyRh/23xp5tOaurjUg1$tiV5fTsrRm.rBAdtroibEydS9HDQ4/R/dbUMBDFfYl. Upon looking up on hash identifier website, it was found to be yescrypt which is not supported to be cracked by both hashcat and john, but\u0026hellip; If we use --format=crypt with john, and the OS is Kali (which natively supports yescrypt) it cracks the hash for us. So, all I did was ran john crackme.txt --format=crypt --wordlis=/usr/share/wordlist/rockyou.txt and waited for it to crack the hash. There we go, we got our password and the flag is PTN{mathematics}\nDiscord After doing million of lookup on the website (tenor.com) ofcourse, I couldnt find anything. I tried to look like bunch of stuffs like frames by frames too. Then at the end I tried to \u0026ldquo;Copy Text\u0026rdquo; and pasted it in my terminal (tbh idk why lol) then found the flag there as PTNCTF24{Let_the_game_begin}. space-me So the website was http://unthinkable.me/ptn-ctf.html where we were supposed to look for the flag. So, I was analyzing the source code and found nothing. Fired up burpsuite and noticed something unusual in response. Since there were alot of spaces and tabs mixed. I saved the spaces/tabs in a h1 file like this:\n┌──(rezy㉿dev)-[~/Downloads/attachments] └─$ echo \u0026#34; \u0026#34; \u0026gt; h1 Then I replaced all the spaces and tabs with 0 and 1 like:\n┌──(rezy㉿dev)-[~/Downloads/attachments] └─$ sed -e \u0026#39;s/\\t/0/g\u0026#39; -e \u0026#39;s/ /1/g\u0026#39; h1 \u0026gt; output_file ┌──(rezy㉿dev)-[~/Downloads/attachments] └─$ cat output_file 10101111101010111011000110111100101010111011100110000100100100111100111010011001110011001010000011001110100011001010000010011110100100111001001110100000100111101001110111001111100010101000101110100000110011111010000011011001101000001100111010000010 I tried to check it\u0026rsquo;s corresponding ASCII value, but nop! I again did the same thing but now tabs by 0 an spaces by 1.\n┌──(rezy㉿dev)-[~/Downloads/attachments] └─$ sed -e \u0026#39;s/\\t/1/g\u0026#39; -e \u0026#39;s/ /0/g\u0026#39; h1 \u0026gt; final ┌──(rezy㉿dev)-[~/Downloads/attachments] └─$ cat final 01010000010101000100111001000011010101000100011001111011011011000011000101100110001100110101111100110001011100110101111101100001011011000110110001011111011000010110001000110000011101010111010001011111001100000101111100100110010111110011000101111101 Then when I check it\u0026rsquo;s corresponding ASCII value, we get our flag as PTNCTF{l1f3_1s_all_ab0ut_0_\u0026amp;_1}. executionar So here we got our ip and the port misc.challenges.ctf.pentesternepal.com 4445. I tried to connect to it using netcat which gives us a python code:\ndef flag(): with open(\u0026#39;flag.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: print(f.read()) blacklist = [ \u0026#39;import\u0026#39;, \u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;breakpoint\u0026#39;, \u0026#39;flag\u0026#39;, \u0026#39;txt\u0026#39;, \u0026#39;read\u0026#39;, \u0026#39;eval\u0026#39;, \u0026#39;exec\u0026#39;, \u0026#39;dir\u0026#39;, \u0026#39;print\u0026#39;, \u0026#39;subprocess\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;echo\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;\u0026#39;\u0026#39;, \u0026#39;open\u0026#39;,\u0026#39;flag\u0026#39;,\u0026#39;blacklist\u0026#39; ] while True: command = input(\u0026#39;Waiting for yours command: \u0026#39;) if any(b in command for b in blacklist): print(\u0026#39;Invalid command!\u0026#39;) continue try: exec(command) except Exception: print(\u0026#39;You have been locked away...\u0026#39;) exit(1337) The Python script above defines a function called flag that reads and prints the contents of a file named \u0026ldquo;flag.txt.\u0026rdquo; It also establishes a list of forbidden words called blacklist, which includes terms like \u0026lsquo;import\u0026rsquo;, \u0026lsquo;os\u0026rsquo;, \u0026lsquo;sys\u0026rsquo;, \u0026lsquo;flag\u0026rsquo;, and \u0026lsquo;open\u0026rsquo;. The script then enters an infinite loop, prompting the user to input a command. If the input command contains any words from the blacklist, the script responds with \u0026ldquo;Invalid command!\u0026rdquo; and prompts the user again. If the command passes the blacklist check, the script attempts to execute it using the exec function. If any exception occurs during execution, the script prints \u0026ldquo;You have been locked away\u0026hellip;\u0026rdquo; and exits with a specific error code. This setup is intended to prevent certain actions and protect sensitive information like the contents of \u0026ldquo;flag.txt.\u0026rdquo;\nThe netcat session also asks me to input a command where I need to write a command to execute. To read flag, I am supposed to get into function flag(). Since we have blacklist in this script we can\u0026rsquo;t do anything much. But\u0026hellip;.\nIn Python there is a global function called globals that returns a dictionary with all global functions and variables of the script.\n$ python3 -q \u0026gt;\u0026gt;\u0026gt; globals() {\u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__doc__\u0026#39;: None, \u0026#39;__package__\u0026#39;: None, \u0026#39;__loader__\u0026#39;: \u0026lt;class \u0026#39;_frozen_importlib.BuiltinImporter\u0026#39;\u0026gt;, \u0026#39;__spec__\u0026#39;: None, \u0026#39;__annotations__\u0026#39;: {}, \u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;builtins\u0026#39; (built-in)\u0026gt;} \u0026gt;\u0026gt;\u0026gt; a = 4444 \u0026gt;\u0026gt;\u0026gt; globals().get(\u0026#39;a\u0026#39;) 4444 They also works great with functions like:\n\u0026gt;\u0026gt;\u0026gt; def f(): ... print(\u0026#39;hey\u0026#39;) ... \u0026gt;\u0026gt;\u0026gt; globals().get(\u0026#39;f\u0026#39;) \u0026lt;function f at 0x101137920\u0026gt; \u0026gt;\u0026gt;\u0026gt; globals().get(\u0026#39;f\u0026#39;)() hey Now, we only need to use a string without single/double quotes. There are several ways, like using a list of integers as bytes or using chr and + like:\n\u0026gt;\u0026gt;\u0026gt; list(b\u0026#39;flag\u0026#39;) [102, 108, 97, 103] \u0026gt;\u0026gt;\u0026gt; bytes([102, 108, 97, 103]).decode() \u0026#39;flag\u0026#39; \u0026gt;\u0026gt;\u0026gt; chr(102) + chr(108) + chr(97) + chr(103) \u0026#39;flag\u0026#39; Now, we have all the pieces. Let\u0026rsquo;s join them and construct a payload: globals().get(bytes((102, 108, 97, 103)).decode())(). All I did was used this command and boom we get our flag.\n┌──(rezy㉿dev)-[~] └─$ nc misc.challenges.ctf.pentesternepal.com 4445 [// .. PYTHON SNIP .. \\\\] Waiting for yours command: globals().get(bytes((102, 108, 97, 103)).decode())() PTNCTF24{d1d_y0u_r34lly_Knew_That} ","permalink":"http://localhost:1313/posts/ctf/ptnctf24/","summary":"Hello guys, this year PTN is hosting 24 hour CTF competition in celebration of 11th Anniversary. The CTF is styled in jeopardy mode. So I, rezydev is playing this CTF with NCA1@Nepal. Let\u0026rsquo;s get into CTF writeup now.\nNo one goes empty handed! The CTF was supposed to be started at 3:00 PM NPT but we were supposed to register our team at 12:00 noon. So, I registered my team and was just looking around the website to read \u0026ldquo;CTF Competition Rules\u0026rdquo;.","title":"Penetester Nepal's 2024 CTF Writeups"}]