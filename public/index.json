[{"content":"Hey there, it\u0026rsquo;s Rezy Dev! Today, we’re going to talk about one of the most important parts of Rust programming—memory management. If you\u0026rsquo;ve been keeping up, you know Rust focuses on safety and performance, and memory management is key to that.\nUnderstanding memory management is essential for writing efficient and safe Rust code. We’ll explore how Rust handles memory using concepts like The Stack, The Heap, Ownership, Borrowing, and more. Ready? Let’s get started!\nThe Stack, the Heap, and Pointers Rust uses two main memory areas: the stack and the heap.\nThe Stack: Think of the stack as a fast and organized place for storing data that has a fixed size and known lifetime. Variables that you define in functions are stored here. It’s like a stack of plates: you add and remove plates in a Last In, First Out (LIFO) order. For example:\nfn stack_example() { let a = 10; // Stored on the stack let b = 20; // Stored on the stack let c = a + b; // Computed and stored on the stack } The Heap: The heap is for data with a dynamic size or unknown size at compile time. It’s like a large storage room where you can put objects and take them out as needed. This comes into play with data that might change in size, like vectors or strings. Here’s an example:\nfn heap_example() { let mut v = Vec::new(); // Vector on the heap v.push(1); v.push(2); let mut s = String::from(\u0026#34;Mom, I\u0026#39;m a hacker.\u0026#34;); // String on the heap println!(\u0026#34;{}\u0026#34;, s); } Ownership and Borrowing Rust’s unique approach to memory management involves ownership and borrowing. This system prevents data races and ensures memory safety.\nOwnership: Every value in Rust has a single owner, and when the owner goes out of scope, the value is automatically dropped. Here’s a basic example:\nfn ownership_example() { let x = String::from(\u0026#34;Mom, I\u0026#39;m a hacker.\u0026#34;); // x owns the string let y = x; // Ownership of the string is transferred to y // println!(\u0026#34;{}\u0026#34;, x); // Error: x no longer owns the string println!(\u0026#34;{}\u0026#34;, y); // Works fine: y owns the string now } Borrowing: You can also borrow a value without taking ownership of it. This is useful for functions that need to read but not modify the data.\nfn borrowing_example(s: \u0026amp;String) { println!(\u0026#34;{}\u0026#34;, s); // Borrowing s, read-only } fn main() { let s = String::from(\u0026#34;Mom, I\u0026#39;m a hacker.\u0026#34;); borrowing_example(\u0026amp;s); // Borrow s println!(\u0026#34;{}\u0026#34;, s); // s is still valid } Mutable References: If you need to modify the data, you can borrow it mutably. Note that you can only have one mutable reference to a value at a time.\nfn mutable_borrow_example(s: \u0026amp;mut String) { s.push_str(\u0026#34;, world!\u0026#34;); } fn main() { let mut s = String::from(\u0026#34;Hello\u0026#34;); mutable_borrow_example(\u0026amp;mut s); // Mutable borrow println!(\u0026#34;{}\u0026#34;, s); // s has been modified } Giving References to Functions: When passing references to functions, ensure that you follow Rust’s borrowing rules to avoid conflicts.\nfn process_string(s: \u0026amp;String) { // Process the string } fn main() { let s = String::from(\u0026#34;Mom, I\u0026#39;m a hacker.\u0026#34;); process_string(\u0026amp;s); // Passing a reference } Copy Types Some types in Rust implement the Copy trait, allowing them to be copied rather than moved. This is generally for simple, fixed-size types like integers.\nfn copy_example() { let a = 5; // i32 is a Copy type let b = a; // Copying a to b println!(\u0026#34;a: {}, b: {}\u0026#34;, a, b); // Both a and b are valid } Lifetimes Lifetimes in Rust are used to ensure that references are valid as long as they are needed. They prevent dangling references and help manage memory safety.\nfn longest\u0026lt;\u0026#39;a\u0026gt;(s1: \u0026amp;\u0026#39;a str, s2: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str { if s1.len() \u0026gt; s2.len() { s1 } else { s2 } } fn main() { let s1 = String::from(\u0026#34;long string\u0026#34;); let s2 = String::from(\u0026#34;short\u0026#34;); let result = longest(\u0026amp;s1, \u0026amp;s2); println!(\u0026#34;The longest string is {}\u0026#34;, result); } Further Reading Since I\u0026rsquo;ve only provided a general overview of how these concepts work, I recommend checking out the following resources for a clearer and more detailed understanding, which will help you become a better programmer. :)\nThe Rust Programming Language - Ownership\nRust Reference - Lifetimes\nRust by Example - Borrowing\nRust Official Documentation - The Stack and the Heap\nRust Official Documentation - Copy Types\nThat’s a wrap for today’s exploration of memory management in Rust! I hope you found this post both informative and fun. As always, feel free to reach out with any questions or comments. Until next time, happy coding!\n","permalink":"http://localhost:1313/posts/rust/memory-management-in-rust/","summary":"Hey there, it\u0026rsquo;s Rezy Dev! Today, we’re going to talk about one of the most important parts of Rust programming—memory management. If you\u0026rsquo;ve been keeping up, you know Rust focuses on safety and performance, and memory management is key to that.\nUnderstanding memory management is essential for writing efficient and safe Rust code. We’ll explore how Rust handles memory using concepts like The Stack, The Heap, Ownership, Borrowing, and more. Ready?","title":"Memory Management in Rust"},{"content":"Welcome back to my Rust series! Today, we\u0026rsquo;re exploring some key concepts: data types and variables. Whether you\u0026rsquo;re working with data during a pentest or creating a custom tool, knowing how Rust manages these basics is crucial.\nTypes In Rust, every value has a specific type, and understanding these types is crucial, especially when handling different data structures. Rust is a statically typed language, which means that all variable types are known at compile time. This feature helps in catching bugs early, something we all appreciate during a lengthy pentest engagement.\nHere’s a quick overview of some basic types:\nIntegers: For when you need to count something (u8, i32, u64, etc.).\nFloating-Point Numbers: Perfect for dealing with calculations that require precision, like timing the response of a server (f32, f64).\nBooleans: True or False, often used in condition checks (bool).\nCharacters: Represents a single character (char).\nTuples: Group multiple values of different types into one compound type.\nArrays: Fixed-size collection of elements, all of the same type. Ideal for holding things like a list of common passwords or IP addresses.\nExample:\nlet ip_addresses: [u8; 4] = [192, 168, 1, 1]; let port_number: u16 = 8080; let is_open: bool = true; Here, ip_addresses is an array of four u8 elements representing an IPv4 address. The port_number is stored as a u16 integer, and is_open is a boolean that might represent the state of a port after a scan.\nType Inference Rust is smart. It often knows the type of a variable without you explicitly telling it. This is called type inference. While Rust’s compiler is very good at figuring out the type, there are times when you need to be explicit, especially when dealing with more complex types or when you want to avoid ambiguity.\nFor example:\nlet response_time = 120.5; // concluded as f64 let host = \u0026#34;10.0.0.1\u0026#34;; // concluded as \u0026amp;str Rust concludes that response_time is an f64 and host is a string slice (\u0026amp;str). This saves time and keeps the code clean.\nMutability In Rust, variables are immutable by default. This is great for security since it prevents accidental modification of data. But, sometimes you need to change the value of a variable, like when updating the status of a service after an exploit. In such cases, you can declare the variable as mutable using the mut keyword.\nExample:\nlet mut service_status = \u0026#34;running\u0026#34;; println!(\u0026#34;Service status: {}\u0026#34;, service_status); service_status = \u0026#34;exploited\u0026#34;; println!(\u0026#34;Service status: {}\u0026#34;, service_status); In this case, service_status starts as \u0026quot;running\u0026quot; but is later updated to \u0026quot;exploited\u0026quot;. By marking the variable as mut, Rust allows this change.\nConstants and static Variables When you know a value won\u0026rsquo;t change throughout the lifecycle of your program, you use a constant. Constants are declared using the const keyword and must always be typed.\nconst MAX_ATTEMPTS: u8 = 5; Here, MAX_ATTEMPTS might represent the number of times you’ll attempt a brute-force attack before moving on.\nRust also has static variables, which are similar to constants but are static items with a fixed address in memory. They can hold references, and unlike constants, they can be mutable (though mutable static variables are not recommended due to potential data races).\nstatic TIMEOUT: u64 = 3000; In this example, TIMEOUT could represent a global timeout value used throughout your application.\nStrings Working with text is something we often do in pentesting, whether it\u0026rsquo;s manipulating payloads, parsing responses, or logging results. Rust provides two main string types: String and \u0026amp;str.\nString: A heap-allocated, growable string. Use this when you need to own and manipulate the string.\n\u0026amp;str: A string slice, which is a reference to a part of a String. It’s useful for passing strings around without needing to own them.\nExample:\nlet payload = String::from(\u0026#34;GET / HTTP/1.1\\r\\nHost: raunak.xyz\\r\\n\\r\\n\u0026#34;); let host = \u0026amp;payload[16..26]; // \u0026#34;raunak.xyz\u0026#34; Here, payload is a String that holds an HTTP request, and host is a \u0026amp;str that slices a part of the payload.\nPrinting with Display and Debug When it comes to outputting data, Rust provides two main formatting traits: Display and Debug.\nDisplay: Used for user-facing output, typically meant to be more readable.\nDebug: Used for developer-facing output, often more detailed and suitable for debugging.\nLet’s say we’re printing out the result of an exploitation attempt:\nlet exploit_result = (\u0026#34;target.com\u0026#34;, 80, true); println!(\u0026#34;Exploit attempt: {:?}\u0026#34;, exploit_result); // Debug println!(\u0026#34;Target: {}, Port: {}, Success: {}\u0026#34;, exploit_result.0, exploit_result.1, exploit_result.2); // Display Using {:?}, we can print a tuple with Debug formatting, and using {}, we can print individual components with Display formatting.\nMore about Printing Rust also supports more complex formatting through macros like format!, print!, and println!.\nlet exploit_result = (\u0026#34;target.com\u0026#34;, 80, true); let report = format!(\u0026#34;Target: {}\\nPort: {}\\nSuccess: {}\u0026#34;, exploit_result.0, exploit_result.1, exploit_result.2); println!(\u0026#34;{}\u0026#34;, report); Here, format! creates a formatted string that we can then print or log.\nConclusion Mastering data types and variables in Rust is key to writing efficient, secure, and strong code. By using Rust’s type system and mutability features, you can manage different data situations accurately and safely.\nFurther Reading The Rust Programming Language - Data Types\nRust By Example - Variables\nRust Reference - Variables and Types\nRust Language - Constants and Static Variables\nRust Documentation - Formatting\n","permalink":"http://localhost:1313/posts/rust/data-types-and-variables-in-rust/","summary":"Welcome back to my Rust series! Today, we\u0026rsquo;re exploring some key concepts: data types and variables. Whether you\u0026rsquo;re working with data during a pentest or creating a custom tool, knowing how Rust manages these basics is crucial.\nTypes In Rust, every value has a specific type, and understanding these types is crucial, especially when handling different data structures. Rust is a statically typed language, which means that all variable types are known at compile time.","title":"Data Types and Variables in Rust"},{"content":"Hey there! I\u0026rsquo;m really pumped to take you on a journey into the world of Rust today. We\u0026rsquo;re going to write our very first Rust program, and I\u0026rsquo;ll explain some key concepts along the way to help you feel like a pro. Let\u0026rsquo;s dive in!\nCargo: The Build System and Package Manager Before we start coding, let\u0026rsquo;s talk about Cargo. Think of Cargo as your best friend in Rust. It\u0026rsquo;s the official build system and package manager for Rust, and it\u0026rsquo;s a game-changer. With Cargo, you can easily manage your projects, handle dependencies, run tests, and even build documentation—all from the command line.\nCargo makes compiling and managing a Rust project much simpler. Instead of manually compiling your code with rustc, Cargo does it for you. It\u0026rsquo;s like having a tool that automates boring tasks, letting you focus on the fun parts.\nSo, why use Cargo instead of rustc directly? While rustc is good for compiling individual files, Cargo is designed for managing whole projects. It helps you keep track of dependencies, ensures your project is built consistently, and makes it easy to share your code with others. In short, Cargo makes life easier, just like how tools like metasploit or nmap make finding vulnerabilities simpler.\nCreating a New Rust Project with Cargo Now, let’s create our first Rust project using Cargo. Open up your terminal and type:\ncargo new hello_rust This command creates a new directory called hello_rust with some files and folders inside. But what exactly did Cargo set up for us?\nWhen you create a project with Cargo, it generates a directory structure that looks something like this:\nCargo.toml: This is the configuration file for your project. It’s written in TOML (Tom’s Obvious, Minimal Language). Here, you can specify your project’s name, version, dependencies, and other metadata. It\u0026rsquo;s like the settings.py in a Django project or package.json in a Node.js project.\nsrc/: This directory contains all your Rust source files. By default, Cargo creates a main.rs file here, which is the entry point of your Rust application.\nCargo also keeps track of a cargo.lock file (once you start adding dependencies). This file ensures that everyone who builds your project uses the exact same versions of your dependencies, maintaining consistency—a crucial aspect in software development.\nWriting Your First Rust Program Alright, enough with the theory—let\u0026rsquo;s write some code! Open the main.rs file inside the src/ directory. You’ll see something like this:\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); } This simple program prints \u0026ldquo;Hello, world!\u0026rdquo; to the console. It\u0026rsquo;s a classic starting point in almost every programming language, and Rust is no exception.\nPrinting in Rust The println! macro is Rust’s way of printing text to the console. Notice the exclamation mark !—this indicates that println! is a macro, not a regular function. Macros in Rust are powerful tools that allow you to write code that writes other code, which can be incredibly useful in many situations. For now, just remember that println! is your go-to for outputting text.\nTo run your program, simply type:\ncargo run Cargo will compile your code and execute the resulting binary. You should see \u0026ldquo;Hello, world!\u0026rdquo; printed on your terminal.\nComments: Documenting Your Code Now that we\u0026rsquo;ve got our program running, let’s talk about comments. As a pentester, I can\u0026rsquo;t stress enough how important it is to document your work. Whether you\u0026rsquo;re writing a pentest report or coding, clear documentation is key.\nRust supports two main types of comments:\nSingle-line comments: These start with // and extend to the end of the line.\n// This is a single-line comment Multi-line comments: These are enclosed in /* */ and can span multiple lines.\n/* This is a multi-line comment. Useful for longer explanations or disabling blocks of code. */ Rust also supports documentation comments, which are a special kind of comment used to generate external documentation. Documentation comments (/// for single lines and /** */ for multiple lines) are used to create API documentation for your code. This is similar to how you might write comments in other languages to explain what a piece of code does, but in Rust, these comments can be automatically compiled into rich, formatted documentation.\n/// This function prints a greeting to the console. fn greet() { println!(\u0026#34;Hello, world!\u0026#34;); } Commenting your code is crucial because it helps others (and your future self) understand what’s happening in your code. It\u0026rsquo;s like leaving breadcrumbs during a pentest to trace your steps or providing detailed explanations in a report.\nConclusion And there you have it—your first Rust program! We\u0026rsquo;ve covered a lot of ground today, from understanding Cargo and its directory structure to writing and running a simple \u0026ldquo;Hello, world!\u0026rdquo; program. We also touched on the importance of comments and documentation in code.\nAs we continue our Rust journey, we\u0026rsquo;ll dive deeper into more complex topics, but for now, enjoy the satisfaction of seeing that \u0026ldquo;Hello, world!\u0026rdquo; printed on your screen. Rust is a powerful language with a lot to offer, and I can’t wait to explore more of it with you.\nHappy coding, and keep documenting!\n","permalink":"http://localhost:1313/posts/rust/writing-our-first-rust-program/","summary":"Hey there! I\u0026rsquo;m really pumped to take you on a journey into the world of Rust today. We\u0026rsquo;re going to write our very first Rust program, and I\u0026rsquo;ll explain some key concepts along the way to help you feel like a pro. Let\u0026rsquo;s dive in!\nCargo: The Build System and Package Manager Before we start coding, let\u0026rsquo;s talk about Cargo. Think of Cargo as your best friend in Rust. It\u0026rsquo;s the official build system and package manager for Rust, and it\u0026rsquo;s a game-changer.","title":"Writing Our First Rust Program"},{"content":"Introduction Rust is a modern programming language that has become popular because it combines speed, control, and safety. It offers the performance and control of languages like C and C++, while also ensuring memory safety, which is a big advantage seen in newer languages like Python. Rust uses new ideas that might be different from what you know in other languages, so it needs careful thought and understanding.\nOne challenge with Rust is that it needs a more structured way of learning. You can\u0026rsquo;t just \u0026ldquo;figure things out as you go.\u0026rdquo; Instead, you need to understand it deeply and practice deliberately.\nRust may be new, but with the right approach, you can master it and write efficient, safe, and reliable code.\nInstallation of Rust in Linux In this series, we will use Linux. The following command should install Rust on our system:\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh Also, make sure to install the CodeLLDB and Rust Analyzer extensions in VS Code so that we can write our Rust code here.\nNow that we have a general overview of Rust and have installed and configured it in VS Code, let\u0026rsquo;s talk about using Rust for cybersecurity\u0026hellip;\nRust for Cybersecurity Rust is becoming a strong tool in cybersecurity, providing many benefits for tasks like penetration testing, automation, bug bounty hunting, and malware development. Its mix of speed, safety, and modern features makes it perfect for these areas. Here’s why Rust is becoming popular in cybersecurity:\n1. Penetration Testing Performance and Control: Rust gives you the low-level access needed for tasks like network scanning, packet crafting, and exploiting vulnerabilities. It offers the speed and control of languages like C or C++, which is important for real-time applications in penetration testing.\nMemory Safety: One of Rust’s best features is its ability to prevent common memory-related issues (e.g., buffer overflows) that can cause security problems. This ensures that the tools you create are not only effective but also secure.\n2. Automation Concurrency: Rust’s ownership model and concurrency features make it great for writing safe, concurrent applications. This is especially useful for automating repetitive tasks in cybersecurity, like brute-forcing passwords or running large-scale scans.\nCross-Platform Development: Rust’s cross-compilation capabilities let you write tools that work well on different operating systems, from Linux to Windows, making your automated tools more versatile.\n3. Bug Bounty Hunting Tooling: Rust is great for making custom tools and scripts for specific bug bounty tasks. Its speed ensures your tools can manage large datasets and complex tasks quickly and efficiently.\nReliability: Rust’s strong type system and compile-time checks help prevent bugs in your tools, allowing you to focus on finding bugs in other systems without worrying about your own tools\u0026rsquo; reliability.\n4. Malware Development Stealth and Efficiency: Rust can create small, efficient programs, which is useful for making lightweight malware that is hard to detect. Its speed also allows for quick execution of harmful actions.\nObfuscation: Rust’s complicated syntax and structure make it harder to reverse engineer, adding extra security for malware developers.\n5. General Benefits Growing Ecosystem: Rust’s ecosystem is growing fast, with many libraries and frameworks useful for cybersecurity tasks. From cryptography libraries to networking crates, Rust has you covered.\nCommunity and Support: The Rust community is very helpful and is expanding quickly in the cybersecurity field. This means as you start using Rust, you’ll have plenty of knowledge and support available.\nConclusion In conclusion, Rust is not just another modern programming language; it\u0026rsquo;s a vital tool for cybersecurity professionals. Whether you’re building sophisticated penetration testing tools, automating complex security tasks, hunting for vulnerabilities, or even developing advanced malware, Rust offers the perfect balance of performance, safety, and flexibility. As the landscape of cybersecurity continues to shift and grow, Rust\u0026rsquo;s influence in the field is poised to expand, making it an essential language for those looking to stay ahead in the game. This marks the beginning of an exciting journey into Rust for cybersecurity on my blog. Stay tuned as we dive deeper into how this powerful language can enhance your skills and projects in the cybersecurity domain.\n","permalink":"http://localhost:1313/posts/rust/introduction-and-installation-of-rust-language/","summary":"Introduction Rust is a modern programming language that has become popular because it combines speed, control, and safety. It offers the performance and control of languages like C and C++, while also ensuring memory safety, which is a big advantage seen in newer languages like Python. Rust uses new ideas that might be different from what you know in other languages, so it needs careful thought and understanding.\nOne challenge with Rust is that it needs a more structured way of learning.","title":"Introduction and Installation of Rust Language"},{"content":"██████╗ ███████╗███████╗██╗ ██╗██████╗ ███████╗██╗ ██╗ ██╔══██╗██╔════╝╚══███╔╝╚██╗ ██╔╝██╔══██╗██╔════╝██║ ██║ ██████╔╝█████╗ ███╔╝ ╚████╔╝ ██║ ██║█████╗ ██║ ██║ ██╔══██╗██╔══╝ ███╔╝ ╚██╔╝ ██║ ██║██╔══╝ ╚██╗ ██╔╝ ██║ ██║███████╗███████╗ ██║ ██████╔╝███████╗ ╚████╔╝ ╚═╝ ╚═╝╚══════╝╚══════╝ ╚═╝ ╚═════╝ ╚══════╝ ╚═══╝ Security Nerd | Rust Dev | CTF Player 🛡️ Personals: My legal name is Raunak Neupane 🙋 I\u0026rsquo;m pursuing Bachlors degree (CS Major) 🎓 I\u0026rsquo;m from Nepal 🇳🇵 Current Hustles: 🕵️‍♂️ Digging through web exploits \u0026amp; 🐛 squashing bugs! 🦀 Jamming with Rust—it’s not just for metal. On My Radar: 🚀 Experimenting with new Rust frameworks and hacking tools. 🛠️ Always chasing the next CTF challenge! Peek into my projects: GitHub Portfolio\nLatest writeups: /posts\nAsk me about: Penetration Testing 💻 Rust Programming 🦀 Python Programming 🐍 Reach me at: mail[at]raunak-neupane.com.np ","permalink":"http://localhost:1313/whoami/","summary":"██████╗ ███████╗███████╗██╗ ██╗██████╗ ███████╗██╗ ██╗ ██╔══██╗██╔════╝╚══███╔╝╚██╗ ██╔╝██╔══██╗██╔════╝██║ ██║ ██████╔╝█████╗ ███╔╝ ╚████╔╝ ██║ ██║█████╗ ██║ ██║ ██╔══██╗██╔══╝ ███╔╝ ╚██╔╝ ██║ ██║██╔══╝ ╚██╗ ██╔╝ ██║ ██║███████╗███████╗ ██║ ██████╔╝███████╗ ╚████╔╝ ╚═╝ ╚═╝╚══════╝╚══════╝ ╚═╝ ╚═════╝ ╚══════╝ ╚═══╝ Security Nerd | Rust Dev | CTF Player 🛡️ Personals: My legal name is Raunak Neupane 🙋 I\u0026rsquo;m pursuing Bachlors degree (CS Major) 🎓 I\u0026rsquo;m from Nepal 🇳🇵 Current Hustles: 🕵️‍♂️ Digging through web exploits \u0026amp; 🐛 squashing bugs!","title":""}]